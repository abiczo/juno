> test post with other inputs (specifically files)
> would reassigning any operators work? i like | for something

>>>> possible: make a global response object for each request, so no explicit return
  is required
  def view(request):
    html("<html>some html code</html>")
    -- or an implicit global response named J (implmenet __call__ for JunoResponse?)
    def view(web):
        J['Content-Type'] = '...'
        J('writing some text here')
        J(status=404)

> make db objects inherit from juno.JunoModel (or just decorate them?)
> alternative url/re syntax?
    @get('/hello/*:name/') or '/hello/:name/'
    def say_hello(request, name):
        return 'Hello, #{name}'

> when a user function gets a request object, allow writing to it to response
    def index(web):
        web.write('Hello world')
        web.write('Content-Type: text/json', type='header')
    -- which causes: 
        def web.write(self, text, type='body')
            # if no JunoResponse, make one
            j.append(text)

> database api:
    Item.all().where(title.contains('urgent'))
    -- or just use the sqlalchemy api?
    -- or:
    model('item', ('name', 'string'))
    data('item').id(4).order('name')
    create('item', name='asdf')

> use python's http server for dev server

> '/media/*:file/' does not match '/media/css/index.css', but it should

> make Juno.dispatch == dispatch(self, url, **kwargs)
    -- kwargs holds any information from request, and a JunoRequest is then built by
       Juno in dispatch.  Thus SCGI is separated from the framework, and testing will be easy
       offline - import juno; juno.dispatch('/')

> notes:
  multilevel decorators:
    @f(arg)
    @d
    def a: pass
    ==
    a = f(arg)(d(a))
