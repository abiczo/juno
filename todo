| means done

> test post with other inputs (specifically files)
> would reassigning any operators work? i like | for something
> implement something like:
    j = JunoResponse().head( title('asdf') + script(src='etc...') ).body( div('asdf') )
    j.div("another div", p("paragraph text in div"))
    j.div("footer")
    - a chainable response constructor, using __getattr__ to build html tags
    -- or --
    j = juno.JunoResponse
    j += juno.JunoHtml().title('asdf')

>>>> possible: make a global response object for each request, so no explicit return
  is required
  def view(request):
    html("<html>some html code</html>")
    -- or an implicit global response named J (implmenet __call__ for JunoResponse?)
    def view(web):
        J['Content-Type'] = '...'
        J('writing some text here')
        J(status=404)

> make db objects inherit from juno.JunoModel (or just decorate them?)
> alternative url/re syntax?
    @get('/hello/*:name/') or '/hello/:name/'
    def say_hello(request, name):
        return 'Hello, #{name}'

> when a user function gets a request object, allow writing to it to response
    def index(web):
        web.write('Hello world')
        web.write('Content-Type: text/json', type='header')
    -- which causes: 
        def web.write(self, text, type='body')
            # if no JunoResponse, make one
            j.append(text)

>>>> implicit urls:
    @get
    def index(web): ...
    # url is function name = '/index/'

> database api:
    Item.all().where(title.contains('urgent'))
    -- or just use the sqlalchemy api?

> use python's http server for dev server

> notes:
  multilevel decorators:
    @f(arg)
    @d
    def a: pass
    ==
    a = f(arg)(d(a))
